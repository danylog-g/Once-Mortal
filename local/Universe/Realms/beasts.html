<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Once Mortal: Realm of Beasts</title>
    <link rel="stylesheet" type="text/css" href="main.css">
    <style>
        .betting-section {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.1);
            border-radius: 5px;
        }
        .betting-odds {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .odds-item {
            flex: 1;
            min-width: 120px;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            text-align: center;
        }
        .odds-value {
            font-weight: bold;
            color: #8aff80;
        }
        .reveal-button {
            background: #4a4a4a;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 0;
        }
        .reveal-button:hover {
            background: #5a5a5a;
        }
        .outcome {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            display: none;
        }
        .winner {
            color: #ffcc00;
            font-weight: bold;
        }
        .payout {
            color: #8aff80;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <a href="../universe.html" class="logo">Once Mortal</a>
        </div>
    </header>
    <div class="container">
        <div class="dashboard-title">
            <h1>Realm of Beasts</h1>
            <p>Wiki Page for Realm of Beasts.</p>
        </div>
        
        <div class="dashboard-balls">
            <h3 class="card-title">Overview</h3>
            <p class="card-description panel">
                <strong>The Realm</strong> <br>
                &emsp;&emsp; A primal, savage world of towering ancient forests, 
                bone-dry deserts of crimson sand, mountains like shattered teeth, 
                churning acidic seas, and labyrinthine cave systems. Life is hyper-aggressive and oversized. 
                Prey animals are deadly; plants are carnivorous or toxic. 
                Resources (clean water, edible plants, safe shelter) are scarce and fiercely contested. 
                The environment itself is a constant predator.
            </p>
            <br>
            <p class="card-description panel">
                <strong>Soniya</strong> <br>
                &emsp;&emsp; An Elder God of unknown origin. Depicted most commonly as a tall, 
                spindly figure composed of dense black smoke forming sharp, jagged "hair." 
                Her eyes are pure, glowing white, emitting their own light. 
                Resides in an imposing, unassailable stronghold within the mythical "Third Realm," 
                a dimension layered over the physical one. <br>
                &emsp;&emsp; Soniya's primary interaction with all the realms is Death Games. 
                She hosts voluntary, arena-based death matches. 
                Participants come from across the multiverse seeking glory. <br>
                &emsp;&emsp; Soniya magically broadcasts these games everywhere. 
                Taverns, palaces, war camps, even divine realms. All can watch the carnage unfold in real-time. 
                This fuels massive gambling rings and provides universal, grim entertainment. <br>
                &emsp;&emsp; The only prize for victory is honor and immortality in the Museum of Heroes. 
                There are no material rewards offered by Soniya. <br>
                &emsp;&emsp; The Museum of Heroes is a colossal 17-story structure within Soniya's stronghold. 
                Each floor holds towering portraits of victors, alongside preserved, 
                mounted heads or full taxidermy of the most fearsome beasts they slew within the Games. 
                It's a monument to violence and survival. <br>
            </p>
            <br>
            <div class="card-description panel">
                <strong>Events</strong> <br>
                <div id="event-info"></div>
                <div id="matchup"></div>
                <div class="betting-section">
                    <h4>Betting Odds</h4>
                    <div id="betting-odds" class="betting-odds"></div>
                    <button id="reveal-outcome" class="reveal-button">Reveal Outcome</button>
                    <div id="outcome" class="outcome"></div>
                </div>
                <div id="refresh">Next matchup in: <span id="countdown"></span></div>
            </div>
            <br>
            <p class="card-description panel">
                <strong>Titans</strong> <br>
                &emsp;&emsp; Unlike other realms, the Realm of Beasts harbors over 30 Titans. 
                This density is unheard of and terrifying. They are the undisputed, absolute rulers. 
                Titans define the food chain. The Titans have carved up the entire realm. <br>
                &emsp;&emsp; Their territories are absolute. Trespassing means instant, 
                catastrophic annihilation. Their presence warps local ecosystems, 
                creating zones of extreme heat, cold, poison, or raw elemental chaos. 
                They are the reason the realm is so lethally overgrown and mutated. They are the environment. <br>
                &emsp;&emsp; Merely existing means avoiding Titan notice. 
                Migration routes, settlements, and resource gathering are dictated by avoiding Titan paths and territories. 
                A Titan shifting its hunting ground is a regional extinction event. 
                The realm's "beasts" are often Titan-spawn or creatures hyper-evolved to survive near them. 
                Possessing colossal size, extreme resilience, unique predatory adaptations, or even parasitic relationships with Titan energies. <br>
                &emsp;&emsp; All other Gods actively avoid the Realm of Beasts. 
                Sending avatars or divine influence risks attracting a Titan's attention. 
                A battle even Gods might lose. Soniya operates safely from Her stronghold,
                seemingly intimidating the Titans, making Her the realm's only consistent divine presence. <br>
            </p>
        </div>
    </div>
    <footer>
        <p>Â© 2025 Once Mortal | Garna | Danylo Gula </p>
    </footer>
    <script>
        // Define naming
        const names = {
            first: {
                name: [
                    "Arne", "Astrid", "Age", "Ase", "Adel", "Adalgisa",
                    "Aelfgar", "Aldred", "Alduin", "Aldwin", "Arnhild",
                    "Alvar", "Ansaldo", "Ansgar", "Atenulf", "Alruna",
                    "Birger", "Bjorn", "Bodil", "Bo", "Bardil",
                    "Cuthwulf",
                    "Erik", "Estrid", "Eadberht", "Ealdgyth",
                    "Eldred", "Elgar", "Erluin", "Eardwulf",
                    "Frida", "Frode", "Fulcoald",
                    "Gertrude", "Gorm", "Gro", "Gudrun", "Gunhild",
                    "Gandulf", "Garrett", "Goswin", "Gundulf", "Gyrd",
                    "Geneva",
                    "Halfdan", "Harald", "Hilda", "Helga", "Hilbert",
                    "Knud", "Kare", "Keno",
                    "Leif", "Liv",
                    "Inga",
                    "Mainard", "Maynard", "Meinhardt", "Maren",
                    "Njal",
                    "Odger", "Osborne", "Oslac", "Osred",
                    "Pandulf", "Purchart",
                    "Quendrida",
                    "Roar", "Rune", "Randi", "Revna", "Rafe",
                    "Richardis", "Roberta",
                    "Sten", "Skarde", "Sune", "Svend", "Signe", "Sigrid",
                    "Sigered", "Sigfried",
                    "Troels", "Toke", "Torsten", "Trygve", "Tora", 
                    "Tove", "Thyra", "Thurid",
                    "Ulf", "Ulfhild",
                    "Wulfhelm",
                    "Yrsa",
                ],
                prefix: [
                    // First Part of Name
                    "Aam", "Am", "Apol", "Abad", "Abez", "Abyz", "Achyl", "Adram",
                    "Adrammel", "Aeshm", "Agal", "Agar", "Ahrin", "Anrin", "Akom",
                    "Akum", "Amdus", "Anath", "Ankt", "Anz", "Ap", "Arch", "Ast",
                    "Ancal", "Acnol", "Alb", "Alf", "Aith", "Ald",
                    "Bab", "Bak", "Bal", "Baph", "Barb", "Bath", "Beel", "Belph",
                    "Bael", "Bal", "Baler",
                    "Camb", "Char", "Cha", "Cho", "Cim", "Cor", "Car", "Chrys", "Chrysoph",
                    "Daev", "Dev", "Dag", "Dajj", "Dec", "Dem", "Drek",
                    "Drac", "Drack", "Drag", "Droc", "Drock", "Drog",
                    "Drakn", "Drav", "Drox", "Drakth", "Dravok",
                    "Dyrn", "Dral", "Droxth", "Dov", "Drakthar",
                    "Ebl", "El", "Eish", "Erl", "Em", "Emb", "Err", "Eld", "Eldr", "Eep",
                    "Foc", "For", "Fur", "Furk", "Forn", "Faf", "Fin",
                    "Gad", "Gaf", "Gam", "Grig", "Gus", "Gun",
                    "Haag", "Hag", "Hal", "Hel", "Hin", "Han",
                    "If", "Ifr", "Inc", "Ip", "Imp", "It",
                    "Jin", "Jik", "Jikin",
                    "Kab", "Kal", "Kar", "Kas", "Kron", "Kram", "Kil", "Kulsh", "Kumb",
                    "Kaz", "Kai", "Kaid",
                    "Lam", "Lat", "Leg", "Lech", "Leon", "Le", "Lem", "Lev", "Lil", 
                    "Lj", "Luc",
                    "Mag", "Mah", "Man", "Mal", "Mar", "Mas", "Mast", "Maz", "Meph", 
                    "Mer", "Mol", "Munk", "Mur", "Mel", "Mer",
                    "Naam", "Nab", "Nal", "Nar", "Nin",
                    "On", "Orc", "Ori", "Oro", "Os", "Oka",
                    "Paim", "Paz", "Pel", "Phen", "Pen", "Poc", "Pon", "Pret",
                    "Prin", "Pulom",
                    "Qin", "Qem", "Qel",
                    "Rah", "Rak", "Ran", "Rav", "Ron", "Rev",
                    "Sab", "Sal", "Sam", "Saph", "Sem", "Shed", "Stol", "Shin",
                    "Saph", "Sel", "Slath", "Shur", "Syr", "Shen", "Siv", "Seth", "Synn",
                    "Tan", "Ten", "Tit", "Toy", "Tuch",
                    "Unc", "Ur",
                    "Val", "Van", "Vap", "Vass", "Vep", "Vin", "Vis", "Vorg", "Vryth", 
                    "Vexx", "Vossk", "Vynth", "Vryx", "Vork", "Vyn", "Vosk", "Vyrn",
                    "Wech", "Wang",
                    "Xaph", "Xez", "Xyrn", "Xanv", "Xulg", "Xyph", "Xyndr",
                    "Xax", "Xir", "Xolth", "Xyr", "Xyndor",
                    "Yan", "Yeq", "Ylth", "Yggd", "Yrth", "Yxal", "Yvrak",
                    "Ysst", "Ythra", "Yxen", "Ynvar", "Yggth",
                    "Zab", "Zag", "Zah", "Zar", "Zep", "Zim",
                    "Zorv", "Zynx", "Zalk", "Zryth", "Zhaan",
                    "Zov", "Zyr", "Zyth", "Zulgr", "Zynvok",
                    "Aurel", "Aether", "Ael", "Aev", "Aur", "Aurum", "Auryn", "Aetheri", 
                    "Aion", "Astr", "Aeg", "Auror", "Aevum", "Auriel", "Aurath",
                    "Cael", "Celest", "Cerul", "Cyne", "Caelum", "Cyr", "Caeli", "Cor", 
                    "Caelest", "Cryph", "Cynar", "Caelor",
                    "Elyon", "Eosph", "Etern", "Elys", "Eman", "Ethere", "Evo", "Exous", 
                    "Eiren", "Eldri", "Eul", "Eon", "Ephra",
                    "Iolar", "Ithir", "Israf", "Irid", "Ion", "Ignis", "Ivo", "Ilios", 
                    "Izar", "Ithiel", "Irath", "Isht",
                    "Orael", "Ori", "Oph", "Olam", "Oner", "Oth", "Ozym", "Oriel", 
                    "Oblat", "Oran", "Ophir", "Orael",
                    "Uriel", "Uthar", "Umbri", "Ur", "Uriel", "Uran", "Unyel", "Ustr", 
                    "Ulth", "Umbr",
                    "Ysrael", "Yphen", "Ygg", "Ynar", "Ylir", "Ythir", "Ysol", "Yph", 
                    "Yss", "Yner",
                ],
                suffix: [
                    // Last Part of Name
                    "as", "at", "ah", "an", "al", "aka", "ai", "ang", "azel", "ael",
                    "aku", "am", "ali", "atos", "ac", "abia", "ap", "aki", "ard",
                    "ami",
                    "bub", "bul", "buth",
                    "ept", "es", "em", "ep", "el", "eus", "eva", "eth",
                    "iel", "im", "ias", "ius", "if", "in", "is", "io", "ion", "ies",
                    "its", "ik", "iu",
                    "la", "lu", "lar", "lis", "las",
                    "ma", "my",
                    "na",
                    "on", "ou", "or", "os", "och", "oth", "ong", "ons", "osh", "ort",
                    "oul", "oin",
                    "ra", "rym", "rith", "rit", "run",
                    "us", "ura", "uer", "uta", "une", "un", "ur",
                    "ys", "yu", "ym", "ya", "yo", "yn",
                    "aedr", "axes", "akai", "aug", "aire",
                    "al", "anth", "ara", "ar", "ax", "axis",
                    "es", "en", "edr", "eep", "ep", "eys",
                    "enth", "er", "ezi", "erth", "ed",
                    "gon", "gar", "gia",
                    "ion", "in", "ira", "ile", "ia", "ike",
                    "kai",
                    "la", "lax", "lia",
                    "nen", "ner", "nir", "ney",
                    "on", "oon", "ol", "oth", "orn",
                    "ogia",
                    "rax", "rex", "ron", "rah",
                    "tur", "ta",
                    "ul", "ung", "urung", "uth", "ug",
                    "uke",
                    "xes",
                    "ys", "yre", "yn",
                    "zi", "zer", "za",
                    "as", "at", "ah", "an", "al", "aka", "ai", "ang", "ael",
                    "aku", "am", "ali", "ac", "abia", "ap", "aki", "ard",
                    "ami", "aedr", "akai", "aug", "aire", "al", "anth", "ara", 
                    "ar", "ax", "adriel", "aion", "alim", "amiel", "aniel", 
                    "aphiel", "ariel", "ari", "asiel", "ath", "athiel", "azra", 
                    "ept", "es", "em", "ep", "el", "eus", "eva", "eth", "es", "en", 
                    "edr", "eep", "ep", "eys", "enth", "er", "ezi", "erth", "ed",
                    "erion", "eros", "estiel", "ethel",
                    "iel", "im", "ias", "ius", "if", "in", "is", "io", "ion", "ies",
                    "its", "ik", "iu", "ira", "ile", "ia", "ike", "il", "ios", "ir", 
                    "ith", "ithiel",
                    "on", "ou", "or", "os", "och", "oth", "ong", "ons", "osh", "ort",
                    "oul", "oin", "oon", "ol", "orn", "ogia", "om", "oriel", 
                    "rael", "riel", "riel",
                    "us", "ura", "uer", "uta", "une", "un", "ur", "ul", "ung", 
                    "urung",  "uth", "ug", "uke", "uel", "uriel",
                    "ys", "yu", "ym", "ya", "yo", "yn", "yre", "yth", "yon",
                ],
            },
            last: {
                prefix: [
                    "Amber", "Ash", "Autumn",
                    "Battle", "Bear", "Black", "Blood", "Blue", "Boulder", "Bright", "Bronze", "Burning",
                    "Cinder", "Cloud", "Copper", "Crimson", "Crystal", "Curse",
                    "Dark", "Dawn", "Dead", "Deep", "Demon", "Dragon", "Dread", "Dusk", "Dust",
                    "Earth", "Ebon", "Elder", "Ember", "Evening",
                    "Fallen", "Far", "Fern", "Fiery", "Fire", "Flame", "Flint", "Frost", "Frozen",
                    "Ghost", "Giant", "Glacier", "Glimmer", "Glorious", "Gold", "Grand", "Gray", "Great", "Green", "Grim",
                    "Hallowed", "Hallow", "Hard", "Hawthorn", "High", "Hollow", "Holy", "Honour", "Howling", "Hunter",
                    "Ice", "Iron",
                    "Jade", "Jagged",
                    "Keen", "Kings",
                    "Lake", "Last", "Light", "Lightning", "Lion", "Lone", "Long", "Lost",
                    "Magma", "Mighty", "Mist", "Moon", "Moss", "Mountain", "Mourning",
                    "Nether", "Nettle", "Night", "Noble", "North",
                    "Oak", "Oaken", "Ocean", "Old", "Pale", "Phoenix", "Proud", "Pure",
                    "Raging", "Rain", "Raven", "Red", "Rune", "Rust",
                    "Sea", "Shadow", "Sharp", "Shattered", "Shifting", "Shining", "Silent", "Silver", "Sky", "Smoke", "Snow", "Solar", "Sorrow", "South", "Spirit", "Spring", "Star", "Steel", "Stern", "Stone", "Storm", "Summer", "Sun", "Swift",
                    "Thunder", "Titan", "Tree", "True",
                    "Umber", "Under",
                    "Valiant", "Void",
                    "War", "Whispering", "White", "Wild", "Wind", "Winter", "Wise", "Wolf", "Wood", "Wraith",
                    "Yellow"
                ],
                suffix: [
                    "axe", "band", "bane", "bash", "beam", "beard", "belly", "blade", "blood", "bloom", "blossom", "bone", "born", "bow", "brace", "branch", "brand", "breaker", "breath", "brew", "bridge", "brook", "brow", "burn",
                    "caller", "chaser", "cleaver", "cloud", "coat", "crest", "cry", "cutter",
                    "dane", "dancer", "dream", "drinker",
                    "eye", "eyes",
                    "fall", "fang", "feather", "field", "fire", "fist", "flame", "flare", "flaw", "fletcher", "flight", "flame", "flower", "force", "forge", "fury",
                    "gaze", "grain", "grass", "guard", "grip", "grove", "guardian",
                    "hair", "hall", "hammer", "hand", "hart", "hunter", "heart", "helm", "hide", "hill", "hoof", "horn", "hunter",
                    "jaw", "keeper", "kin",
                    "lake", "lance", "leaf", "light", "mane", "mark", "mantle", "master", "might", "moon", "mourn",
                    "pelt", "pike", "pelt", "proof",
                    "rage", "rain", "reaper", "rider", "ridge", "river", "root", "runner",
                    "scar", "scream", "seeker", "shadow", "shard", "shield", "shout", "skin", "sky", "slayer", "snarl", "song", "spear", "spell", "spire", "spring", "stalker", "star", "steed", "step", "stone", "storm", "stride", "strike", "strider", "surge", "sworn", "sword",
                    "tail", "talon", "tear", "thorn", "throat", "tide", "tooth", "tracker", "trail", "trap", "treader", "tree",
                    "vein", "view", "voice",
                    "walker", "ward", "water", "weaver", "whisper", "wind", "wing", "wolf", "wood", "wrath",
                    "yard"
                ]
            },
            titles: [

            ],
        };
        function createFirstName(seed) {
            if (seed >= 0.5) {
                return names.first.name[Math.floor(seed * names.first.name.length)];
            }
            const pref = names.first.prefix[Math.floor(seed * names.first.prefix.length)];
            const suff = names.first.suffix[Math.floor(seed * names.first.suffix.length)];
            return pref + suff;
        }
        function createLastName(seed) {
            const pref = names.last.prefix[Math.floor(seed * names.last.prefix.length)];
            const suff = names.last.suffix[Math.floor((seed * 1.61803398875) % 1 * names.last.suffix.length)];
            return pref + suff;
        }
        // Define named monsters
        const monsters = [
            "Gowran"
        ];
        // Define hardcoded teams for team-based events
        const teams = {
            silkball: [
                ["Silk Spinners", "Velvet Vipers"],
                ["Satin Serpents", "Lace Lancers"],
                ["Taffeta Titans", "Chiffon Chargers"],
                ["Brocade Brawlers", "Damask Duelists"]
            ],
            mage_tower: [
                ["Eldrin the Wise", "Morgana Fireheart", "Zephyr Windsong"],
                ["Thalia Stormcaller", "Orin Stonehand", "Lyra Moonwhisper"],
                ["Kael Sunstrider", "Seraphina Lightweaver", "Darius Shadowmancer"],
                ["Fenris Frostweaver", "Isolde Ironwill", "Corvus Nightshade"]
            ]
        };

        // Define events with their configurations
        const events = {
            gladiator: {
                name: "Gladiator Fight",
                minParticipants: 2,
                maxParticipants: 16,
                supportedTypes: ["FFA", "TDM", "1vM", "TvM"],
            },
            silkball: {
                name: "Silkball Tournament",
                minParticipants: 2, // Number of teams
                maxParticipants: 4, // Number of teams
                supportedTypes: ["TDM"],
            },
            mage_tower: {
                name: "Mage Tower",
                minParticipants: 2, // Number of teams
                maxParticipants: 4, // Number of teams
                supportedTypes: ["TDM"],
            },
            sunderdome: {
                name: "The Sunderdome",
                minParticipants: 4,
                maxParticipants: 12,
                supportedTypes: ["FFA", "TDM"],
            },
            beast_hunt: {
                name: "Great Beast Hunt",
                minParticipants: 3,
                maxParticipants: 8,
                supportedTypes: ["FFA", "TDM"],
            },
        };

        // Function to generate a deterministic random number based on date
        function getSeededRandom(seed) {
            let hash = 0;
            for (let i = 0; i < seed.length; i++) {
                const char = seed.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs((hash * 0.0000000004656612873077392578125) % 1);
        }

        // Function to generate random individual names
        function generateIndividualName(seed, index) {
            const random = seed + "participant" + index;
            const firstName = createFirstName(getSeededRandom(random + "first" + index * 7));
            const lastName = createLastName(getSeededRandom(random + "last" + index * 13));
            //const title = Math.random() > 0.7 ? " " + titles[Math.floor(random * titles.length)] : "";
            
            console.log(`${firstName} ${lastName}`);
            return `${firstName} ${lastName}`;
        }

        // Function to select a random event and type
        function selectRandomEvent() {
            // Change to 3-hour blocks instead of daily
            const now = new Date();
            const threeHourBlock = Math.floor(now.getTime() / (3 * 60 * 60 * 1000));
            const dateSeed = threeHourBlock.toString();
            
            // Use date to select event
            const eventKeys = Object.keys(events);
            const eventRandom = getSeededRandom(dateSeed + "event");
            const eventIndex = Math.floor(eventRandom * eventKeys.length);
            const eventKey = eventKeys[eventIndex];
            const event = events[eventKey];
            
            // Use date to select event type
            const typeRandom = getSeededRandom(dateSeed + "type");
            const typeIndex = Math.floor(typeRandom * event.supportedTypes.length);
            const eventType = event.supportedTypes[typeIndex];
            
            // Use date to select participant count
            const countRandom = getSeededRandom(dateSeed + "count");
            const participantCount = Math.floor(
                countRandom * (event.maxParticipants - event.minParticipants + 1)
            ) + event.minParticipants;
            
            return {
                event: event,
                eventType: eventType,
                participantCount: participantCount
            };
        }

        // Function to select participants based on event type
        function selectParticipants(event, type, count) {
            const seed = new Date().toISOString().slice(0,10) + "participants";
            
            if (type === "FFA") {
                return selectFFAParticipants(event, count, seed);
            } else if (type === "TDM") {
                return selectTDMTeams(event, count, seed);
            } else if (type === "1vM") {
                return select1vMParticipants(event, count, seed);
            } else if (type === "TvM") {
                return selectTvMParticipants(event, count, seed);
            }
        }

        // Free For All participant selection - uses generated names
        function selectFFAParticipants(event, count, seed) {
            const participants = [];
            
            for (let i = 0; i < count; i++) {
                participants.push(generateIndividualName(seed, i));
            }
            
            return {
                type: "FFA",
                participants: participants
            };
        }

        // Team Death Match team selection
        function selectTDMTeams(event, count, seed) {
            // For silkball and mage_tower, use predefined teams
            if (event.name === "Silkball Tournament" || event.name === "Mage Tower Duel") {
                const eventTeams = teams[event.name === "Silkball Tournament" ? 'silkball' : 'mage_tower'];
                const selectedTeams = [];
                const availableTeams = [...eventTeams];
                
                // Select the required number of teams
                for (let i = 0; i < Math.min(count, availableTeams.length); i++) {
                    const index = Math.floor(getSeededRandom(seed + i) * availableTeams.length);
                    selectedTeams.push(availableTeams[index]);
                    availableTeams.splice(index, 1);
                }
                
                return {
                    type: "TDM",
                    teams: selectedTeams
                };
            } else {
                // For other events, generate teams with individual participants
                const teams = [];
                const participantsPerTeam = Math.max(2, Math.floor(count / 2));
                
                for (let i = 0; i < participantsPerTeam; i++) {
                    const team = [];
                    for (let j = 0; j < 2; j++) { // 2 participants per team
                        team.push(generateIndividualName(seed, i * 2 + j));
                    }
                    teams.push(team);
                }
                
                return {
                    type: "TDM",
                    teams: teams
                };
            }
        }

        // One vs Monster(s) participant selection
        function select1vMParticipants(event, count, seed) {
            // Select one participant
            const participant = generateIndividualName(seed, 0);
            
            // Select monsters (1-3 monsters)
            const monsterCount = Math.min(Math.floor(getSeededRandom(seed + "monster") * 3) + 1, count - 1);
            const selectedMonsters = [];
            const availableMonsters = [...monsters];
            
            for (let i = 0; i < monsterCount; i++) {
                if (availableMonsters.length === 0) {
                    availableMonsters.push(...monsters);
                }
                const index = Math.floor(getSeededRandom(seed + i) * availableMonsters.length);
                selectedMonsters.push(availableMonsters[index]);
                availableMonsters.splice(index, 1);
            }
            
            return {
                type: "1vM",
                participant: participant,
                monsters: selectedMonsters
            };
        }

        // Team vs Monster(s) participant selection
        function selectTvMParticipants(event, count, seed) {
            // Generate a team of 2-4 participants
            const teamSize = Math.min(Math.floor(getSeededRandom(seed + "team") * 3) + 2, count - 1);
            const team = [];
            
            for (let i = 0; i < teamSize; i++) {
                team.push(generateIndividualName(seed, i));
            }
            
            // Select monsters (2-4 monsters)
            const monsterCount = Math.min(count - teamSize, 4);
            const selectedMonsters = [];
            const availableMonsters = [...monsters];
            
            for (let i = 0; i < monsterCount; i++) {
                if (availableMonsters.length === 0) {
                    availableMonsters.push(...monsters);
                }
                const index = Math.floor(getSeededRandom(seed + "m" + i) * availableMonsters.length);
                selectedMonsters.push(availableMonsters[index]);
                availableMonsters.splice(index, 1);
            }
            
            return {
                type: "TvM",
                team: team,
                monsters: selectedMonsters
            };
        }

        // Function to generate betting odds
        function generateBettingOdds(participants, seed) {
            const odds = {};
            let totalStrength = 0;
            
            // Assign random strengths to each participant
            participants.forEach(participant => {
                const strength = getSeededRandom(seed + participant) * 100 + 10; // 10-110 strength
                odds[participant] = {
                    strength: strength,
                    probability: 0
                };
                totalStrength += strength;
            });
            
            // Calculate probabilities and payout odds
            Object.keys(odds).forEach(participant => {
                const probability = odds[participant].strength / totalStrength;
                odds[participant].probability = probability;
                // Calculate payout (inverse of probability with house edge)
                odds[participant].payout = (1 / probability) * 0.85; // 15% house edge
            });
            
            return odds;
        }

        // Function to determine winner based on odds
        function determineWinner(odds, seed) {
            const participants = Object.keys(odds);
            const randomValue = getSeededRandom(seed + "winner");
            
            let cumulativeProbability = 0;
            for (const participant of participants) {
                cumulativeProbability += odds[participant].probability;
                if (randomValue <= cumulativeProbability) {
                    return participant;
                }
            }
            
            // Fallback to last participant
            return participants[participants.length - 1];
        }

        // Function to display the matchup
        function displayMatchup() {
            const eventKeys = Object.keys(events);
            const { event, eventType, participantCount } = selectRandomEvent();
            const matchup = selectParticipants(event, eventType, participantCount);
            
            // Display event info
            const eventInfo = document.getElementById('event-info');
            eventInfo.innerHTML = `
                <p><strong>></strong> ${event.name} <strong>-</strong> ${getTypeDescription(eventType)}</p>
                <p>Participants: <strong>${participantCount}</strong></p>
            `;
            
            // Display matchup based on type
            const container = document.getElementById('matchup');
            container.innerHTML = '';
            
            // Prepare participants list for odds calculation
            let participantsForOdds = [];
            let participantNames = [];
            
            if (matchup.type === "FFA") {
                matchup.participants.forEach((participant, index) => {
                    const participantElement = document.createElement('div');
                    participantElement.className = 'participant';
                    participantElement.innerHTML = `- <strong>${index + 1}</strong> ${participant}`;
                    container.appendChild(participantElement);
                    participantsForOdds.push(participant);
                    participantNames.push(participant);
                });
            } else if (matchup.type === "TDM") {
                matchup.teams.forEach((team, index) => {
                    const teamElement = document.createElement('div');
                    teamElement.className = 'team';
                    teamElement.innerHTML = `<strong>Team ${index + 1}:</strong> ${team.join(', ')}`;
                    container.appendChild(teamElement);
                    participantsForOdds.push(`Team ${index + 1}`);
                    participantNames.push(`Team ${index + 1}: ${team.join(', ')}`);
                });
            } else if (matchup.type === "1vM") {
                const participantElement = document.createElement('div');
                participantElement.className = 'participant';
                participantElement.innerHTML = `<strong>Champion:</strong> ${matchup.participant}`;
                container.appendChild(participantElement);
                
                const monstersElement = document.createElement('div');
                monstersElement.className = 'monsters';
                monstersElement.innerHTML = `<strong>Monsters:</strong> ${matchup.monsters.join(', ')}`;
                container.appendChild(monstersElement);
                
                participantsForOdds.push(matchup.participant);
                participantsForOdds.push("Monsters");
                participantNames.push(matchup.participant);
                participantNames.push("Monsters: " + matchup.monsters.join(', '));
            } else if (matchup.type === "TvM") {
                const teamElement = document.createElement('div');
                teamElement.className = 'team';
                teamElement.innerHTML = `<strong>Team:</strong> ${matchup.team.join(', ')}`;
                container.appendChild(teamElement);
                
                const monstersElement = document.createElement('div');
                monstersElement.className = 'monsters';
                monstersElement.innerHTML = `<strong>Monsters:</strong> ${matchup.monsters.join(', ')}`;
                container.appendChild(monstersElement);
                
                participantsForOdds.push("Team");
                participantsForOdds.push("Monsters");
                participantNames.push("Team: " + matchup.team.join(', '));
                participantNames.push("Monsters: " + matchup.monsters.join(', '));
            }
            
            // Generate and display betting odds
            const seed = new Date().toISOString().slice(0,10) + "odds";
            const odds = generateBettingOdds(participantsForOdds, seed);
            const winner = determineWinner(odds, seed);
            
            const bettingOddsContainer = document.getElementById('betting-odds');
            bettingOddsContainer.innerHTML = '';
            
            participantsForOdds.forEach((participant, index) => {
                const oddsElement = document.createElement('div');
                oddsElement.className = 'odds-item';
                oddsElement.innerHTML = `
                    <div>${participantNames[index]}</div>
                    <div class="odds-value">${odds[participant].payout.toFixed(2)}x</div>
                    <div>(${(odds[participant].probability * 100).toFixed(1)}%)</div>
                `;
                bettingOddsContainer.appendChild(oddsElement);
            });
            
            // Store winner information for reveal
            window.currentWinner = {
                name: winner,
                payout: odds[winner].payout.toFixed(2)
            };
            
            // Reset outcome display
            document.getElementById('outcome').style.display = 'none';
            document.getElementById('outcome').innerHTML = '';
            
            // Update the countdown timer
            updateCountdown();
        }

        // Helper function to get description for event type
        function getTypeDescription(type) {
            const descriptions = {
                "FFA": "Free For All",
                "TDM": "Team Death Match", 
                "1vM": "One vs Monster(s)",
                "TvM": "Team vs Monster(s)"
            };
            return descriptions[type] || type;
        }

        // Function to update countdown until next matchup (3 hours)
        function updateCountdown() {
            const now = new Date();
            const nextUpdate = new Date(now);
            // Calculate next 3-hour interval
            const currentHour = now.getHours();
            const hoursToAdd = 3 - (currentHour % 3);
            nextUpdate.setHours(nextUpdate.getHours() + hoursToAdd);
            nextUpdate.setMinutes(0, 0, 0);
            
            const diff = nextUpdate - now;
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            document.getElementById('countdown').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            displayMatchup();
            
            // Add event listener for reveal button
            document.getElementById('reveal-outcome').addEventListener('click', function() {
                const outcomeDiv = document.getElementById('outcome');
                outcomeDiv.innerHTML = `
                    <p><span class="winner">Winner: ${window.currentWinner.name}</span></p>
                    <p>Payout: <span class="payout">${window.currentWinner.payout}x</span> your bet</p>
                `;
                outcomeDiv.style.display = 'block';
            });
            
            // Update countdown every second
            setInterval(updateCountdown, 1000);
            // Update matchup every 3 hours
            setInterval(displayMatchup, 3 * 60 * 60 * 1000);
        });
    </script>
</body>
</html>